% This section describes the outcome of your work and summarizes your efforts.
% It also outlines things that are left to do to reach a full solution, or to integrate your solution with something else.

% The conclusion from the results

The result from comparing the debuggers was a bit disappointing.
Because, \gls{erdb} was not able to improve on the main problem with debugging optimized code, i.e. that variables are often displayed as optimized out.
Making it impossible for the user to understand what is happening in the program.


The debugging library \emph{rust-debug} is successful in simplifying the process of retrieving debug information from \gls{DWARF}.
It is a extremely versatile library because it has very few dependencies, where \emph{gimli-rs} is one of the dependencies.
Also, it does not block the user from using \emph{gimli-rs} directly.


Overall, I would say that the goal of this thesis was achieved, but that there is still a lot that needs to be done.
Both to the development of debugging tools and the compiler.


\section{Potential Future Debugging Improvement}
% Future work that can be done on the llvm
The ranges for the location information seems to be set a bit to tightly by \emph{LLVM} in some cases, meaning that the value still is in the debugged target for some time after the end address of the given address range.
There are three major factors that affect the variable location correctness, they are mentioned in section \ref{section:loc-ranges}.
A potential improvement to debugging would be to improve how the variable location ranges are set.


\section{Future Debugger Improvement}
% Future work that can be done on the debuger side.
The debugger \gls{erdb} only supports the most important functionalities of a debugger.
Thus, there is many more features that could be added.
One important one, left for future work, is the ability to evaluate expressions.
This is a hard problem because the evolution of the expressions should work the same as in the \emph{Rust} compiler.
It would be best if the same code could be used so that it does not need to be written twice.


% Future work that can be done on the debuger side.
One of the main problems with debugging optimized code is that the variables are stored in registers and never pushed to the stack.
This causes the variables to be overwritten when they are not needed anymore.
That fact makes debugging very hard, because the user must halt the execution when the variable still exists.
However, if the debugger could get the last value of the variable and store it, the last known value of the variable could then be displayed to the user instead.


%\section{Future Debugger Library Improvement}
%% Future work that can be done on the debuger side.
%Currently the debugging library \emph{rust-debug} is not able to display values stored on the heap.
%It will instead show the pointer to the heap location where the value is stored.
%This problem is a little bit hard because the pointer is a data structure, thus it is hard to determine if it is a pointer or not.
%Implementing a solution for this is left as future work.


