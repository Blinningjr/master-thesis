% This section describes the outcome of your work and summarizes your efforts.
% It also outlines things that are left to do to reach a full solution, or to integrate your solution with something else.

% The conclusion from the results


The result from comparing the debuggers could have been a lot better.
\gls{erdb} could not improve on the main problem with debugging optimized code, i.e., variables are often displayed as optimized out, which makes it impossible for the user to understand what is happening in the program.


The debugging library \emph{rust-debug} successfully simplifies retrieving debug information from \gls{DWARF}.
It is a highly versatile library because it has very few dependencies.


Overall, the goal of this thesis was achieved.
However, many developments still need to be done to the compiler and debugging tools.



\section{Potential Future Debugging Improvement}
The ranges for the location information seem to be set a bit too tightly by \emph{LLVM} in some cases, meaning that the value still is in the debugged target for some time after the end address of the given address range.
Three significant factors affect the variable location correctness, as mentioned in section \ref{section:loc-ranges}.
A potential improvement to debugging would be to improve how the variable location ranges are set.



\section{Future Debugger Improvement}
The debugger \gls{erdb} only supports the most important functionalities of a debugger.
Therefore, there are many more features that could be added.
One important one, left for future work is the different stepping variations.
The ability to step one source code instruction and step in and out of functions is valuable when debugging because it makes it easy to traverse the code while debugging.


One of the main problems with debugging optimized code is that the variables are stored in registers and never pushed to the stack.
It causes the variables to be overwritten when they are not needed anymore.
That fact makes debugging very hard because the user must halt the execution when the variable still exists.
However, if the debugger could get the last value of the variable and store it, the last known value of the variable could then be displayed to the user instead.
