% Why is your work important? Typically this section relates strongly to the problems that you define in 1.3.
% The motivations can be societal, economical, or other things, but try and look past the task at hand and find out what impact your results will have.

% Motivations bullet points
%	* Optimized rust code is up to 100 faster.
% 	* Improving the state of debugging.
% 	* Contributing with a solution written in Rust.
% 	* Contributing a debug rust library / simplifying debugging.
% 	* Shinning a light on the obstacles.
%	* Companies spend lot of money on testing but not on verifying if there program is correct, which debugging is a important tool for verifying.


% Optimized rust code is up to 100 faster.
The main motivation is that optimized \emph{Rust} code can be $10-100$ times faster then unoptimized code according to \cite{perf-book}.
That is a very large difference in speed compared to other compilers like \emph{Clang} for example, were the optimized code is about 1-3 times faster then the unoptimized code according to \cite{clang-opt}.
Thus for language like \emph{C} it is much more acceptable to not be able to debug optimized code because the difference is not that large compared to \emph{Rust}.
But in the case of \emph{Rust} the difference is so large that some programs are too slow to run without optimization.
This causes the problem that the code cannot be debugged because debuggers do not work well on optimized code and unoptimized code is too slow to run.
Because of that there is a need for better debuggers that can provide a good experience debugging optimized \emph{Rust} code.


% Debugging is not as important for rust, but is still needed for embedded systems
A argument against the need of low level debugging is that the \emph{Rust} compiler will catch most of the errors.
This is especially true regarding pointers and memory access, which are two common causes of bugs in programming languages like \emph{C} and \emph{C++}. 
Thus there is a less need for debugger that can debug \emph{Rust} code then there are debuggers that can debug \emph{C} and \emph{C++} code.
But when it comes to embedded applications there is sill a need for low level debugging, such as a debugger.


% Improving the state of debugging. % TODO: Rewrite this paragraph
Another motivation for creating a debugger for embedded systems is that the two supported debuggers for \emph{Rust} by the \emph{Rust} team are \emph{LLVM} and \emph{GDB}, which both requires another program to interact with the \gls{mcu}.
An example of such a program that is commonly used is \emph{openocd}(openocd homepage \cite{openocd}), which needs to be setup as a \emph{GDB} server that the debugger connects to.
This complicates the process of debugging and makes for a bad experience, especially for new developers.


% Contributing with a solution written in Rust.
Most of the debuggers used for \emph{Rust} code are written in other programming languages and there is not a lot of debugging tools written in \emph{Rust} yet.
Thus one of the motivation is to write a debugger in \emph{Rust}, this will also lead to the debugger having all the benefit of memory safety that \emph{Rust} provides.


%% Contributing a debug rust library / simplifying debugging.
%Another way this thesis contributes to the \emph{Rust} community is by making a library that simplifies the process of retrieving information from the debug information.
%This is important because it makes retrieving debug information simpler for new developers to start contributing to the \emph{Rust} debug community.
%Which will hopefully lead to more work being done on the compiler to improve the debugging situation for unoptimized and  optimized \emph{Rust} code.


