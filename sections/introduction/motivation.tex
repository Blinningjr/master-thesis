% Why is your work important? Typically this section relates strongly to the problems that you define in 1.3.
% The motivations can be societal, economical, or other things, but try and look past the task at hand and find out what impact your results will have.

% Motivations bullet points
%	* Optimized rust code is up to 100 faster.
% 	* Improving the state of debugging.
% 	* Contributing with a solution written in Rust.
% 	* Contributing a debug rust library / simplifying debugging.
% 	* Shinning a light on the obstacles.
%	* Companies spend lot of money on testing but not on verifying if there program is correct, which debugging is a important tool for verifying.


% Optimized rust code is up to 100 faster.
The main motivation is that optimized \emph{Rust} code can be $10-100$ times faster than unoptimized code according to the \emph{Rust} performance book \cite{perf-book}.
That is a very large difference in speed compared to other compilers like \emph{Clang} for example, were the optimized code is about 1-3 times faster than the unoptimized code according to the paper \cite{clang-opt}.
Thus for a language like \emph{C}, it is much more acceptable to not be able to debug optimized code because the difference is not that large compared to \emph{Rust}.
But in the case of \emph{Rust} the difference is so large that some programs are too slow to run without optimization.
This is a problem because debuggers are bad at debugging optimized code and unoptimized code is to slow to run.
That is way there is a need for better debuggers that can provide a good experience for debugging optimized \emph{Rust} code.


% Debugging is not as important for rust, but is still needed for embedded systems
An argument against the need of low level debugging is that the \emph{Rust} compiler will catch most of the errors.
This is especially true regarding pointers and memory access, which are two common causes of bugs in programming languages like \emph{C} and \emph{C++}. 
Thus there is less need for a debugger that can debug \emph{Rust} code than there are debuggers that can debug \emph{C} and \emph{C++} code.
However when it comes to embedded applications there is still a need for low level debugging, with such a debugger.


% Improving the state of debugging. % TODO: Rewrite this paragraph
Another motivation for creating a debugger for embedded systems is that the two supported debuggers for \emph{Rust} by the \emph{Rust} team are \emph{LLVM} and \emph{GDB}, which both requires another program to interact with the \gls{mcu}.
An example of such a program that is commonly used is \emph{openocd}(openocd homepage \cite{openocd}), which needs to be setup as a \emph{GDB} server that the debugger connects to.
This complicates the process of debugging and makes for a bad experience, especially for new developers.


% Contributing with a solution written in Rust.
Most of the debuggers used for \emph{Rust} code are written in other programming languages and there is not a lot of debugging tools written in \emph{Rust} yet.
Thus one of the key motivations is to write a debugger in \emph{Rust}, which will also lead to the debugger having all the benefit of memory safety that \emph{Rust} provides.


%% Contributing a debug rust library / simplifying debugging.
%Another way this thesis contributes to the \emph{Rust} community is by making a library that simplifies the process of retrieving information from the debug information.
%This is important because it makes retrieving debug information simpler for new developers to start contributing to the \emph{Rust} debug community.
%Which will hopefully lead to more work being done on the compiler to improve the debugging situation for unoptimized and  optimized \emph{Rust} code.


