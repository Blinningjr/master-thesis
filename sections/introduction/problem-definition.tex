% This is really the section you should start writing first, even if it's located as 1.3.
% What scientific problems are you solving in your thesis.
% The reason why you should start defining these is that they define what you should write in all the other sections.
% The introduction gives an overview of the area of your problems.
% The background offers the background to why you are working with your problems.
% The motivation gives a motivation to why you are solving the problems.
% The related work described work which relates to your problems.
% The implementation describes how you have implemented a solution to your problems.
% The evaluation evaluates whether you have actually solved your problems.
% The discussion discusses each individual problem, how you addressed it, alternative solutions and shortcomings, etc.
% The conclusions and future work describes the final outcome of how you solved your problems and what is left to do. 
 
% If you write your problems first it is so much easier to write all the other sections because you already know what the focus of each section should be. It prevents a lot of the writers block that people often suffer from.


There are two main problem that this thesis tries to tackle to improve the experience of debugging optimized code for embedded systems.
The fist problem is about the generation of the debug information, if more debug information can be generated then there is more information the debugger can retrieve an show the user.
This is also were the problem starts with debugging optimized code, because debuggers needs the debug information to understand the relation between the source code and the machine code.
Thus it is very important that the compiler generates as much debug information as possible, because there is nothing that can be done later to get more information.
The first problem then is to look at the different options that can be set in the \emph{llvm} compiler to improve the generations of debug information without impacting the optimisation of the code to much.
Speed of the resulting code is still a big priority.


The second problem is looking at the available debug information that the \emph{llvm} compiler generates for optimized code and creating a debugger that utilises that information to the fullest.
This problem has two parts to it, the first being retrieving the needed information from the debug information.
This will be the hardest part and is the most important for improving the debugging for optimized code.
The second part is to display the debug information to the user in a user friendly way.


The goal of solving these to problems is to create a debugger that gives a better debugging experience for optimized rust code on embedded systems then some of the most commonly used debugger, such as \emph{gdb} and \emph{lldb}.
And to inspire further development for debugging tools in the rust community.

