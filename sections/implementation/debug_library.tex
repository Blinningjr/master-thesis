% Explain the implementation of the library rust-debug

% Explain why this library was made.
Retrieving debug information from the \gls{DWARF} sections in the \gls{elf} file is one of the main problems that needs to be solved when creating a debugger.
The \emph{Rust} library \emph{gimli-rs} simplifies that problem by providing data structures and functions for reading the \gls{DWARF} sections.
But the library requires a lot of knowlage about the \gls{DWARF} format to use.
Thus the \emph{rust-debug} library was created to make it even eaiser to get the debug information.
Figure \ref{fig:rustdebug} shows how the two libaries and the \gls{elf} file are connected.


\begin{figure}[h]
	\centering
	\includegraphics[width=1.0\textwidth]{rust_debug.png}
	\caption{A diagram showing the relation between the \emph{ELF} file and the two libraries \emph{rust-debug} and \emph{gimli-rs}.}
	\label{fig:rustdebug}
\end{figure}


Some of the main functionality that \emph{rust-debug} provides are the following:

\begin{itemize}
  \item Retriving the Source location for funcitons, variables, types and more.
  \item Virtually unwinding the call stack.
  \item Evaluating variables.
  \item Translating soruce file line number to the nearest machine code address.
\end{itemize}

There is more functionalities that \emph{rust-debug} provides but they are not notisable.



\subsubsection{Retriving Source Location}
% Explain the evaluation of source informaiton % TODO
Some of the \glspl{die} in \gls{DWARF} have attributes that starts with \emph{DW\_AT\_decl\_}.
These attributes contain infomation on where in the source file the \gls{die} was decleard.
This include file path, line number and column number.
The library \emph{rust-debug} has a function for retrieving the value of all these attributes from a given \gls{die}.


The attribute  \emph{DW\_AT\_decl\_file} wich contain the file path of where the \gls{die} was decleard has a file indexd as it's value.
Every compliation unit has a line number information table that contain file paths which are index.
Thus the \emph{rust-debug} libary will search for the maching index in the table to find the file path.
Finding the line and column number does not require any lookup. there attributes contain the value.


\subsubsection{Accessing Memory And Registers}
% Explain the evaluation part. % TODO
% Explain the stored target memory and registers
As mention before one of the requirements for evaluating the value of a variable is access to the registers and memory of the debug target.
This library does not have that functionality because the problem of accessing memory and register is out of scope for this library.
The reason being that it would limit the number of systems it could be used for too the systems it support and also the goal of this library is to make it simpler to get debug information from \gls{DWARF}, and not to provide an interface to the systems memory and register.
That lead to the motivation of creating a data structure that holds these needed values of the system.
The implementation is just a struct with two hashmaps, one for the memory values and one for the register values.
It also has some methods for retrieving the stored values.
This struct is then used as an argument to the functions in the library and if a value that is not present in the data structure is needed the result of the function call will be a request to add the to the data structure and call the function again.
This has a negative effect in that some of the calculations will be repeated multiple times but it is not very notable.


\subsubsection{Evaluating Variables}
% Explain the evaluation of vairbles.
The library has a structure called \emph{VariableCreator} which  takes a reference to the \gls{DWARF} unit and die of the variable.
Then there is a evaluation method that takes the memory and registers data structure and preforms calculation to evalue and retrieve variable information.
This method return an enum that either tell the user what memory or register values are needed, or that the it is done and the method \emph{get\_variable} can be used to get the variable.
The variable structure contains the name, value, type, sourcelocaiton and the location of where the value was evaluated from.


\subsubsection{Evaluating Call Stack}
% Explain the evaluation of call stack % TODO
% Explain the evaluation of stackframe 
Using the call stack result each call frame can be used to create a stack frame.
These stack frames are like the call frames except that they have more information like the function name of the frame, where the function was declared and the value of all the variables.
The way this library  constructs a \emph{StackFrame} struct works the same way as when creating a variable.
Meaning that there is a helper struct for creating the stack frame which requires the memory and register struct as an argument.
This helper struct when created will find the name of the function for this frame and where it was declared, then it will go through all dies that belong to that function to find all the variable dies and store it in a list.
This list of variable dies is then used to evaluate all variables and each entry is removed when evaluated and the result stored in a variables attribute.
Thus if one of the variables requires a value from memory that is not present in the memory and register struct then all the variables already evaluated doesn't need to be evaluated again.
The evaluating of the variables is done in the same way as describe above the only difference is that the registers values is set to be the ones evaluated in the call frame.
Thus adding the value of a register to the memory and register struct won't do anything when evaluating a stack frame.
Then lastly the stack frame can be retrieve using the method \emph{get\_stack\_frame} from the stack frame helper struct.


\subsubsection{Finding Breakpoint Location}
% Explain how to get breakpoint locaiton.
There is also a function for finding out what machine code address a certain line in a source file corresponds to.
It works by first finding out which compilation unit that the source file corresponds to by looping trough all the file entries in all of the compilation units. 
Then it loops through all the rows in that file entry and adds all the rows that match the source line number.
If the vector is empty after that then there is no machine code instruction that matches that source line otherwise it is not empty there is at least one instruction that corresponds to that line.
When there are multiple match the function will take the one that has the nearest column value to the source lines column value.

