% Describe the test setup to verify that your problems from 1.3 have been solved.
% This can be done in different ways depending on focus of your problems.
% Some problems may purely objective, such as "improve the performance of X compared to Y".
% These are easy to evaluate since you simply need to compare the performance, and perhaps compare against a few more technologies that you have listed in Section 2 (related work).
% In other cases the problems may be very subjective, such as "Create a mobile app that can be used while driving, and which shows the most fuel efficient time to change gear".
% This problem will require a user-study in which several persons drive without the application, you calculate the fuel consumption, then they drive with the application and then you calculate the fuel consumption again.
% Then you collect the objective measurements (fuel consumption comparisons) and the subjective opinions from the users about whether the application was unobtrusive, usable, etc. (typically via a questionnaire).

% TODO: Remove
There are three problems that this thesis tries to solve, they are mentioned in section \ref{sec:problemDef}.
The three following section will go thought how each of the problems were evaluate and what the results are.


\section{Evaluating \emph{rust-debug}}
The debugging library \emph{rust-debug} aims to solve the problem of it being difficult to get debug information from the \gls{DWARF} format.
Where the difficult part is that it requires many lines of code and knowledge about the \gls{DWARF} format, to get the debug information wanted.
Thus, one way to measure if \emph{rust-debug} makes it easier to retrieve debug information, is to compare the amount of code lines it takes to create a debugger with and without using \emph{rust-debug}.


Unfortunately there is no other debugger that has the exact same features as \gls{erdb}.
And it would be unfair to compare \gls{erdb} with a debugger like \emph{GDB}, which has a lot more features.


Instead the number of lines in \emph{rust-debug} will be compared against the debugger module in \gls{erdb}.
The number of \emph{Rust} code lines will be counted using the tool \emph{tokei} \cite{tokei}.
\emph{rust-debug} contains $3550$ lines of \emph{Rust} code, and the debugger module contains $1310$ lines.
Also, the whole debugger \gls{erdb} contains $2834$ lines of \emph{Rust} code.


The amount of \emph{Rust} code in \emph{rust-debug} is more then double that of the debugger module in \gls{erdb}.
Thus, \emph{rust-debug} has made it significantly easier to get some debug information.



\section{Evaluating \emph{ERDB}} % TODO
% List all the features it has.
One of the requirements set in the section \ref{sec:problemDef} was that \gls{erdb} needs to implement some of the most common debugging features.
A list of these features is can be found in section \ref{sec:delimitations}.
\gls{erdb} implements all of those mentioned features, but there are two of them that is not fully supported.


% stepping, sw breakpoints, 
Currently \gls{erdb} only supports hardware breakpoints, thus there is a limit to how many breakpoints can be set.
To have more breakpoints the debugger needs to support software breakpoints, which will make it possible to have a lot more breakpoints.
The other feature that is not fully supported are the different stepping variants.
Stepping one machine code instruction is currently the only supported stepping function.
But, it would have been very useful if it supported stepping one source code instruction.


% Dose not require external program for embedded systems.
One of the main goals of \gls{erdb} was to improve the user experience, by mainly removing the hassle of using a external program to debug embedded systems.
\gls{erdb} has achieved this goal by using the \emph{probe-rs} library.
\emph{probe-rs} allows \gls{erdb} to access the debug target without starting another program, which greatly improves the user experience.
There is also a \emph{vscode} extension for \gls{erdb} that makes the user experience equally as good as other debuggers.


% TODO: Compare to erdb, gdb and lldb.

\section{Debugging Optimized Out Variables} % TODO

