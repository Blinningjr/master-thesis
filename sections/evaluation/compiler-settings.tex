% Describe the test setup to verify that your problems from 1.3 have been solved.
% This can be done in different ways depending on focus of your problems.
% Some problems may purely objective, such as "improve the performance of X compared to Y".
% These are easy to evaluate since you simply need to compare the performance, and perhaps compare against a few more technologies that you have listed in Section 2 (related work).
% In other cases the problems may be very subjective, such as "Create a mobile app that can be used while driving, and which shows the most fuel efficient time to change gear".
% This problem will require a user-study in which several persons drive without the application, you calculate the fuel consumption, then they drive with the application and then you calculate the fuel consumption again.
% Then you collect the objective measurements (fuel consumption comparisons) and the subjective opinions from the users about whether the application was unobtrusive, usable, etc. (typically via a questionnaire).

The \emph{Rust} compiler has some compiler options that the user can set when compiling a project that effect the code generation and the debug information.
It also enables the user to access some of the compiler options for \emph{LLVM} that is the backend of the compiler.
The first part to finding if any of these compiler options effect the debug information generated in a meaningful way is to read what they do and determine if they might do that.
Then the compiler options need to be tested manually to see if any of them actually have any meaningful effect and that the option doesn't effect the speed of the optimised code in a negative way.
This is very hard to do and takes a lot of time to do it properly, thus the testing done will be limited to checking the \gls{DWARF} file and the debugging experience.


When going through all the possible \emph{rustc} compiler options for code generation that are listed in the \emph{rustc book} \cite{rustc-book-codegen}, there where two that have the most impact on the amount of debug information generated.
The most important one of these is the flag named \emph{debuginfo} which controls the amount of debug information generated.
It has three option, the first is option $0$ which means that no debug info will be generated.
The second option is $1$ which will only generate the line tables and the last is option $3$ which generates all the debug information it can.
Thus it is clear from the description in the \emph{rustc book} that this flag should always be set to $3$ when debugging.


The other key compiler option is the optimization flag named \emph{opt-level}, it controls the amount of optimization done to the code and which type of optimization, size or speed.
Comparing the different optimization levels the debug information got less and less when a higher optimization level was set on a simple blink code example.
The highest optimization level for speed is $3$ and the result from using is that the debug information got very limited, thus making it extremely hard to debug.
In the testing of the three optimization level $1$, $2$ and $3$ it seams that optimization level $2$ worked the best for debugging without making the program too slow.


There are two other \emph{rustc} compiler option flags that is important for debugging but sometimes not necessary depending on the target.
The first one is called \emph{force-frame-pointers} and does what is say, it force the use of frame pointers \cite{rustc-book-codegen}.
The other one is called \emph{force-unwind-tables} which forces the compiler to generate unwind tables in the \gls{DWARF} file \cite{rustc-book-codegen}.
These two flags set to \emph{`yes`} can ensures that the debugger can unwind the stack and display the callstack to the user.


Looking through all the \emph{LLVM} arguments that is available through \emph{rustc} yielded one more argument that effects the debug information generated.
The argument is named \emph{debugify-level} and controls the kind of debug information that is added to the \gls{DWARF} file.
There are two options for this argument, the first is called \emph{"location+variables"} and adds locations and variables to \gls{DWARF}.
The other option is called \emph{"locations"} and only adds locations to \gls{DWARF}.
When testing out both of these options on optimized code there was no noticeable difference in the debugging experience and no noticeable difference in the  \gls{DWARF} file.




%\subsubsection{rustc settings}
%\subimport{}{rustc.tex}
%
%
%\subsubsection{LLVM settings}
%\subimport{}{llvm.tex}

