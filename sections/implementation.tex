% This is not a step-by-step instruction or diary to your work.
% Instead, you should describe your technical approach and solution, describe architecture, components, etc.
% Think software engineering...
% Perhaps use a few useful uml-diagrams or illustrate the system architecture.
% Keep in mind that the purpose of the implementation section is to describe your implementation to solve the problems from 1.3.
 
% This section can have a lot of subsections, example:
% 4.1 System architecture / System arkitektur
% 4.2 System components / System komponenter
% 4.3 ...

There are three different project that make up the implementation.
The first being a debug library called \emph{rust-debug}, which purpose is to simplify the process of retrieving debug information from the \gls{DWARF} format.
The second project is the debugger \gls{erdb}, that implements the \gls{dap} protocol.
And the last one is a \emph{VSCode} extension that launches the \gls{erdb} debugger and connect to it.


\section{Debugging Library \emph{rust-debug}}
\label{section:rust-debug}
% Explain the implementation of the library rust-debug

% Explain why this library was made.
Retrieving debug information from the \gls{DWARF} sections in the \gls{elf} file is one of the main problems that needs to be solved when creating a debugger.
The \emph{Rust} library \emph{gimli-rs} simplifies that problem by providing data structures and functions for reading the \gls{DWARF} sections.
However, the library requires the user to be knowledgeable about the \gls{DWARF} format, the target system and the programming language/compiler used.
Thus, the \emph{rust-debug} library was created to make it possible to get information from the \gls{DWARF} format for someone without that knowledge.

Some of the main functionality that \emph{rust-debug} provides easy solutions for are the following:

\begin{itemize}
  \item Retrieving the source code file location for were functions, variables, types and more are declared.
  \item Virtually unwinding the call stack.
  \item Evaluating variables.
  \item Translating source file line number to the nearest machine code address.
  \item Finding the \gls{die} that represents a function using the name.
\end{itemize}

There are more functionalities that \emph{rust-debug} provides, but they are less noteworthy.
The code for this library is in the \emph{GitHub} repository \cite{rust-debug}.



\subsection{Retrieving Source Code File Location} \label{sec:decl}
% Explain the evaluation of source information 
In the \emph{DWARF} format, the source code location of where any type of data was declared, is stored in three attributes on the \gls{die} that represents that data.
One of the attributes contain indirect information about which file the data was declared, another contain the line number and the last one contain the column number.


The attribute contain the file path and name information is called \emph{DW\_AT\_decl\_file}.
It does not contain the file path and name directly, instead it contains a file index.
This file index is used to lookup the file path and name in a table called, \emph{line number information table}.
There is one such table in each compilation unit, and the file index $0$ is special.
File index $0$ is reserved for when a source file can not be specified.


The source code line and column number can be read directly from the attributes \emph{DW\_AT\_decl\_line} and \emph{DW\_AT\_decl\_column} respectively.
Thus, they are much easier to retrieve.


\emph{rust-debug} provides a function that performs the lookup file index lookup, and it also gets the line and column numbers.
The function requires that a \gls{die} and related compilation unit is given.
But, the library has other function for retrieving the required information.


\subsection{Accessing Memory And Registers}
% Explain the evaluation part.
% Explain the stored target memory and registers
Some of the functionalities in the \gls{DWARF} format requires access to register and memory values.
One of them, is the evaluation of variables values.


Accessing the debug targets registers and memory is a different problem from reading and using the \gls{DWARF} format.
Thus, \emph{rust-debug} lets the user of the library solve that problem.
This has the benefit that any existing solutions can be used, like \emph{probe-rs}.
But it also has one downside, \emph{rust-debug} is a little bit harder to use because of extra work the user has to do.


All the functionalities in \emph{rust-debug} that requires access to the registers requires a struct from the library called \emph{Registers}.
This struct contains a \emph{HashMap} with the register numbers and there corresponding values.
It also contains the register number of some special registers, like the \arc{pc} register.
Thus, it is up to the user that the correct register numbers and values are stored on the struct.  
An example on how this can be implemented can be found in the git repository for \gls{erdb} \ref{erdb}.


The functionalities that requires access to the memory of the debug target, requires a struct that implements the \emph{rust-debug} trait \emph{MemoryAccess}.
This trait is very simple and only has one function, which is for reading a varied amount of bytes at a given address.
Thus, the user can create a struct that implements that function almost however they want.
An example on how this can be implemented using the \emph{probe-rs} library can be found in the git repository for \gls{erdb} \ref{erdb}.



\subsection{Evaluating Variables} \label{sec:ievalvar}
% Explain the evaluation of variables.
To make evaluating the value of a variable and retrieving other information about the variable easy, \emph{rust-debug} provides a struct called \emph{Variable}.
That struct only has one function called \emph{get\_variable}, which takes a \gls{die} and returns a \emph{rust-debug} \emph{Variable} struct.
The \emph{rust-debug} \emph{Variable} struct may contain the following information:


\begin{itemize}
  \item Variable name.
  \item Variable value, type and location on the debug target. All this information is stored in a tree structure.
  \item Variable declaration location, the file, line and column.
\end{itemize}


All the information in the \emph{Variable} struct may not be present, because not all \glspl{die} contain the information the struct may have.


The evaluated value of a variable is represented in a tree structure which is very similar to how the information is stored in the \gls{DWARF} format.
But, the value of each branch is evaluated into a value of one of the basic types, such as a signed integer.
Thus, it removes the hardest part of evaluating a variable, without losing the flexibility of the \gls{DWARF} format.
The only down side of this solution is that it requires the user understand how variables are structure in the \gls{DWARF} format.


\subsection{Finding the current function} \label{sec:funcdie} % TODO: Explain in more detail what the function does.
When debugging, knowing the current function that is being executed is very useful.
Finding that function can be done by finding the function \gls{die} that is furthest down the \gls{die} tree, in the branch where the current address is in range.
Thus, the function \gls{die} can easily be found by tracking all the function \glspl{die} while going down the \gls{die} tree.
\emph{rust-debug} makes this even easier by providing a function that does exactly this.


% OLD
%The \emph{rust-debug} library has a function for finding a \gls{die} that represents a function using the name of that function.
%The function also needs a machine code address to find the correct compilation unit.
%
%
%The correct compilation unit can be found using a code address.
%Every compilation unit has an address range that can be used to see if the machine code is from that compilation unit.
%Thus searching for the correct one is done by going through each unit, and checking if the address is in the range.
%
%
%When the compilation unit is known, the \gls{die} representing the subroutine can be found by searching the \gls{die} tree of the unit.
%This is done by going down the path of the tree where the machine code address is in range.
%It returns a result when it has found the subroutine \gls{die} with the searched name, or when there are no more \glspl{die} to check.


\subsection{Unwinding the Call Stack}
% Explain the evaluation of call stack 
% Explain the evaluation of stackframe 

The \emph{rust-debug} library has a function for virtually unwinding the current call stack, and it does it in two separate steps.
Unwinding the call stack to get all the register values for each stack frame, is the first step.
The second step is to find the subroutine and to evaluate all the variables for each stack frame.


Unwinding the call stack to get the register values is done by a separate function, which returns a \emph{Vec} of \emph{CallFrame} structs.
Where each \emph{CallFrame} struct contain information about each of the stack frames.
The most important information the struct contains is the unwound register values, but it also contain other useful information, such as the start and end memory address of the stack frame.
All the information in the struct is retrieved using the method described in section \ref{sec:stacktrace}.


In the second step, the function loops through all the \emph{CallFrame} structs and tries to retrieved all the information it can about the stack frame.
This includes the name of the subroutine and the declaration location, which is found using the function describe in section \ref{sec:decl}.
It also includes the variable information that retrieved using the function describe in section \ref{sec:ievalvar}.



\subsection{Finding Breakpoint Location}
% Explain how to get breakpoint location. 
The \emph{rust-debug} library has a function that finds a machine code address using a source code location.
This machine code location is the closest one that represents the given line in the source code.
The function requires a file path and line number, but it also can take a column number.


The mentioned function works by first finding out which compilation unit contains information on the inputted file path.
It does this by looping through all the file entries in the line number information table for every compilation unit.
Each line number information table entry have rows that each contain information on a line from the source code.
Thus, all the rows with the search line numbers are added to a list.
The machine code address of the first element in this list is returned if no column line was inputted to the function.
Otherwise, it is the one with the closest column number that is returned.




\section{Embedded Rust Debugger}
% Explain the genral stucture of the debugger
The debugger \acrfull{erdb} is implemented using the debugging library \emph{rust-debug}, which requires the \emph{gimli-rs} library.
\emph{rust-debug} provides all the needed functionalities for retrieving debug information from the \gls{DWARF} format.
The debugger also uses the \emph{probe-rs} library for controlling the debug target, it is also used for accessing the registers and memory of the debug target.


The debugger is made up of three modules, the first one is called \acrshort{cli}.
Its main functionality is to handle the input and output from the console.
The second module is called \emph{DebugAdapter}.
It also handles the input and output, but in the form of \gls{dap} messages.
These \gls{dap} messages are sent through a \arc{tcp} connection, and is for supporting the \gls{dap} protocol.
The last module is called \emph{Debugger}, it is for getting debug information and controlling the debug target.



The debugger is implemented asynchronously, because all the modules handle input, either from the user or from the debug target.
Thus, the main function of the debugger waits for input from any of the modules, and then handles them.
Figure \ref{fig:ERDStruct} shows a diagram of how these modules are structured.


\begin{figure}[h]
	\centering
	\includegraphics[width=1.0\textwidth]{debugger_structure.png}
	\caption{Diagram showing the structure of ERD.}
	\label{fig:ERDStruct}
\end{figure}


The code for \gls{erdb} can be found in this git repository \cite{erdb}.


\subsection{The CLI Module} % TODO
% Explain how the CLI is implemented.
The \acrshort{cli} module is very simple, it only has two jobs.
The first is to parse the input into a request that the \emph{Debugger} module can understand.
And the second is to convert the responses it gets from the \emph{Debugger} module to text, and output that text to the terminal.


% OLD
%The \emph{CLI} is a very simple one, that has a separate thread for reading the input called the input thread.
%The input is read from the console constantly until the user enters a line of text.
%Then the inputted line is sent to the main thread.
%After that the input thread waits for a response, the type of the response is boolean.
%If the response boolean is true then the program will stop, otherwise it starts reading the console for new input again.
%The input thread repeats this process until the main thread stops it.
%
%
%When the main thread receives a message from the input thread it tries to parse it into command.
%The parser works by matching the first word in the input with the names of the commands.
%If there is a match the commands specific parser is used to parse the rest of the input.
%After a command is parsed, it is sent to the debug thread asynchronously.
%The main thread then waits for a response from the debug thread, when the response is received the main thread prints it to the console.
%After that it sends a response to the input thread and awaits new messages from both the input thread and the debug thread.
%
%
%An example of all the communication between the user and the threads can be seen in figure \ref{fig:cliflow}.
%The example also shows what happens when an event is sent from the debug thread to the main thread.
%An event is a message telling the debugger that the debug target has change state from running to stopped or vice versa.
%
%
%\begin{figure}[h]
%	\centering
%	\includegraphics[width=0.9\textwidth]{cli_flow.png}
%	\caption{A diagram showing the communication between the user/actor and the three different threads.}
%	\label{fig:cliflow}
%\end{figure}




\subsection{The Debug Adapter module}
% Explain the implementaiton of the debug adapeter


% Overview description of the debug adapter and the flow of communication from the user to the debugger.
The debug adapter is implemented as a \gls{tcp} server in the main thread.
When a new \gls{tcp} connection is made the debug thread is started.
After it has started the main thread starts listening for \gls{dap} messages on the \gls{tcp} connection.


The first \gls{dap} messages are for communicating the \gls{dap} functionalities that the client and the debugger has.
These first \gls{dap} messages also contain some configuration for debugger module in the debug thread, those configuration are forwarded to the debug thread.
After that the debug adapter will continuously pull for messages from the \gls{tcp} client and the debug thread, until a message is received.


When the debug adapter receives a \gls{dap} message from the client, it is translated into one or more commands.
Those commands are then sent one by one to the debugger module in the debug thread.
The responses from those commands are then used to make a response to the clients \gls{dap} message.
If the debug adapter gets an event from the debug thread, the debug adapter will translate it into a \gls{dap} message and send it to the client.



%% Add a flow cart of the communication? % TODO
%\begin{figure}[h]
%	\centering
%	\includegraphics[width=0.9\textwidth]{user_dap_debug.png}
%	\caption{A diagram showing the comunication between the user/actor, \emph{VSCode} and the debugger \emph{Embedded Rust Debugger}.}
%	\label{fig:userDAP}
%\end{figure}





\subsection{The Debugger Module}
The debugger module is designed as a server that listens for commands through a channel.
It is running in a separate thread from the \acrshort{cli} and the debug adapter, which is called the debug thread.
There are two states in which the debug thread can be in, that is in the attached or detached state.
The two states are different in that the attached state can access the debug target and the \gls{DWARF} file.


The debug thread is started by the main thread and starts in the detached state.
In the detached state only the configuration and exit commands work.
The other commands require that the debug target is attached.
But if one of those commands is received then the debug thread will try to enter the attached state.
This can only happen if all the required configuration are set.
If one of the configuration are missing then an error will be sent as a response.


When the debug thread is in the attached state it can use the \emph{rust-debug} library to retrieve debug information.
It can also use the \emph{probe-rs} library for controlling the debug target and reading the registers and memory.
The relation between the libraries can be seen in figure \ref{fig:debugger}.


\begin{figure}[h]
	\centering
	\includegraphics[width=1.0\textwidth]{debugger.png}
	\caption{A diagram showing the relations between the debugger, the \emph{ELF} file, the debug target and the two libraries \emph{rust-debug} and \emph{probe-rs}.}
	\label{fig:debugger}
\end{figure}


\subsubsection{Retrieving Debug Information}
The debugger module retrieves debug information by using the \emph{rust-debug} library.
This library sometimes requires a data structure that contain the values of some registers and memory addresses.
Those function will return an enum that tells if a value is needed and where that value is located.
Thus, the debugger module will use the \emph{probe-rs} library to read the needed value, which is then added to the data structure.
This repeats until no more values are needed, and the result of the evaluation can be retrieved.
The values in the data structure are removed every time the debug target starts executing again.
This is such that no old values are used, and it works because the debug target must be stopped to use related commands.



\subsubsection{Simultaneous Handling of Requests And Events}
% How the debugger handles request and events simultaneously.
The debug thread polls the channel for incoming request and the state of the debug target.
This enables the debug thread to simultaneously handle requests from the user, and events from the debug target.
There is a boolean that keeps track if the debug target is running.
It is used to stop the pulling of the targets state when the debug target is stopped.
This is done because the debug target cannot start executing on its own.


\subsubsection{Optimization of Repeated Variable Evaluation}
% How it handles request for stackframes and variables.
To improve on the performance of the debugger it will temporarily store the values of the stack trace.
This allows for fast repetitive lookup of information present in the stack trace.
The stored stack trace is removed any time the debug target starts executing again.
This ensures that it always gives the correct values and not the old ones.


Note that if a request is received to evaluate one variable, the debugger will then perform a stack trace instead, or read from the temporarily stored stack trace.
This simplifies the implementation a lot and also makes the subsequent evaluation requests faster.


\section{VSCode Extension}
% Explain the implementation of the vscode explanation.
Creating a \emph{VSCode} extension is simple because \emph{Microsoft} has a tool called \emph{TODO} \ref{TODO}, that will generate a empty extension.
They also have a lot of documentation on how to get started with creating a extension.
The documentation mentions how to create debug extensions.
There is two different types of debug extensions, the first is a extension that implements a debug adapter for a specific debugger.
These often require a lot work because a debug adapter needs to translate the \gls{dap} protocol messages to command that the debugger understands.
Thus, depending on the debugger it can require a lot of work to get this working well.
The other type of debug extension is just a wrapper for the debugger that already implements the \gls{dap} protocol.
These extension are very simple to create because the they only need to start the debugger and connect to it using the \emph{dap} protocol.
I refer the reader to \emph{Microsofts} documentations \ref{TODO} for further reading.

The debugger \emph{Embedded Rust Debugger} implements the \gls{dap} protocol over a \gls{tcp} server.
Thus, the \emph{VSCode} extension is just a wrapper that starts the debugger \gls{tcp} server and then connects to it.
Connecting to the debugger server over \gls{tcp} is very easy to do, because \emph{Microsoft} has a library called \emph{VSCode} that does that for you.
The extension also captures the logs of the debugger and outputs them to the user using the \emph{VSCode} library.

There are also some configurations that the user of the \emph{Embedded Rust Debugger} can set in the \emph{launch.json} file.
The available configurations are defined in a \emph{json} file called \emph{TODO} in the extension project.
