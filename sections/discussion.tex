% Discuss how you solved your problems from 1.3, and what the results were (from section 5).
% Describe alternative solutions, what you could have done differently, problems you encountered, how your results compare to other peoples results, etc.
% Go through each problem individually, and then in the end add general remarks and discussion points which are outside the problems themselves but that you think may be valuable to share with the reader.
% This section can have several subsections.


% Overall Discussion of how the problem is solved

\section{Usefulness of \emph{rust-debug}}
The \emph{rust-debug} library makes it much easier to get information from \gls{DWARF}.
One reason is that it requires much less knowledge about \gls{DWARF}.
Also, the documentation for \emph{rust-debug} is much less text than the specification for the \gls{DWARF} format.
Therefore, reading and understanding take less time, making it easier to use.


The amount of code needed to get the debug information is much less using \emph{rust-debug}, as section \ref{sec:evalrd} shows.
Using the number of code lines to measure complexity is not the most accurate method.



\section{Debug Experience For Optimized Rust Code}
At the beginning of this thesis, it was thought that \emph{GDB} could not evaluate variables located in registers.
This thought came from the observation that \emph{GDB} mainly prints that the variables are \emph{optimized out} when debugging optimized code.
Therefore, it was thought that those variables were not wholly removed from the optimized code.
However, \emph{GDB} was right in that they were wholly optimized out.


With these expectations in mind, the result in section \ref{sec:debuggercomparison} is disappointing because the goal was to create a debugger that could improve on this problem.


Unexpectedly, both \emph{GDB} and \emph{LLDB} have other minor problems.
Such as, \emph{GDB} parsed $64$-bit integers as $32$-bit.
Those minor problems might be specific to the debugger's \gls{cli} and thus not present in other releases of the debuggers.
However, the problems show that \gls{erdb} has some slight advantages.



\subsection{Debugging Rust Code on Embedded Systems}
% My Results Compared to expected results
The experience of debugging \emph{Rust} code on embedded systems with both \emph{LLDB} and \emph{GDB} is not very good.
There are a lot of configuring, and both require a program like \emph{openocd} that handles the communication between the debugger and the target device.
Using \gls{erdb} is easier, because it removes the step of starting a separate program.


\section{Accuracy of the DWARF Location Ranges}\label{section:loc-ranges}
% The accuracy of the Location list entry ranges.
While working on \emph{rust-debug} and \gls{erdb} it was discovered that variables can sometimes live longer on the debugged target then described in \gls{DWARF}.
This means that some variables can potentially be read when \gls{DWARF} says that they have no location.


The documentation for \emph{LLVM} \cite{llvm-dbs} mentions three major factors that effect the variable location fidelity, they are:

\begin{enumerate}
  \item Instruction Selection
  \item Register allocation
  \item Block layout
\end{enumerate}

The documentation about the three major factors does not mention a lot about how the ranges could be set too tight.
Thus, to be able to find if this can be improved on, there has to be a good understanding of \emph{LLVM}, which is out of scope for this thesis.


The documentation also mention that some location changes are ignored by \emph{LLVM} in some situations.
One situation they mention, is that location changes is ignored for the prologue and epilogue code of a function.
However, this should not be a problem, because most debuggers will step over the prologue and epilogue code.

