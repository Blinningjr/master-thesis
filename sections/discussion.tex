% Discuss how you solved your problems from 1.3, and what the results were (from section 5).
% Describe alternative solutions, what you could have done differently, problems you encountered, how your results compare to other peoples' results, etc.
% Go through each problem individually, and then in the end add general remarks and discussion points which are outside the problems themselves but that you think may be valuable to share with the reader.
% This section can have several subsections.


% Overall Discussion of how the problem is solved


\subsection{Debug Information Generation}
% My Results Compared to expected results
This thesis was not really able to improve the amount of debug information generated by \gls{rustc} and \gls{LLVM}.
There are some options mention in the section \ref{sec:settingscomparison} that generate debug information, but they are well known.
Thus the result presented there is noting new for most developers that program in \emph{Rust}.
To really improve on the amount of debug information generated one has to work on the compiler \emph{rustc} or \gls{LLVM}.


\subsection{Debug Experience For Optimized Rust Code}
% My Results Compared to expected results
At the beginning of this thesis it was thought that \gls{GDB} was not able to evaluate variables with values stored in registers.
This thought came from the observation that \gls{GDB} for the most part prints that almost all variables are optimized out,  when debugging optimized code.
Thus it was thought that those variables were completely removed from the optimized code.
But as it turns out they weren't, instead they were just optimized out at that particular point.


Keeping these expectation in mind the result in section \ref{sec:debuggercomparison} were a bit disappointing.
The only improvement that could be made for this problem is that different messages are displayed for the different cases.
This makes it much clearer to the user how the variable is optimized out.


Unexpectedly there was another problem with the debuggers \gls{GDB} and \gls{LLDB} that could be improved on.
That problem is that both mentioned debuggers had problems with the evaluation of the \emph{Rust} \emph{enum} type.
The reason for this problem is that many other programming language doesn't allow \emph{enums} to have any value stored in them like \emph{Rust} allows.


The \gls{LLDB} debugger had much more problems with this then \gls{GDB} which only gave the wrong value when the enum variant was optimized out.
Thus unexpectedly the debugger in this thesis could improve on that by evaluating the correct value.
And in the case of the value of the  enum variant being optimized out it could display that it was optimized out, thus not giving the wrong value as \gls{GDB} does.


\subsubsection{Debugging Rust Code On Embedded Systems}
% My Results Compared to expected results
The experience of debugging \emph{Rust} code on embedded systems with both \gls{LLDB} and \gls{GDB} is not very good.
There is a lot of configuring that has to be done and both require a program like \emph{openocd} that handles the communication between the debugger and the target device.
Removing this need of using a program like \emph{openocd} made the debugging experience a lot better using the debugger presented in this thesis.
The reason being that it takes fewer steps to start debugging.


\subsubsection{Contributing to the Rust Debug Community}
% My Results Compared to expected results
This problem is huge and complex thus to really make a change in more people have to contribute.
One of the best ways of getting more people involved is by making it easier to contribute.
The debugging library \emph{rust-debug} does just that by simplifying the process of retrieving debug information from \gls{DWARF}.
If more developers start using \emph{rust-debug} will force the library to also become better and intern also force \emph{gimli-rs}, \gls{rustc}, \gls{LLVM} and \gls{DWARF} to become better.

