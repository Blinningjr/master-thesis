% Discuss how you solved your problems from 1.3, and what the results were (from section 5).
% Describe alternative solutions, what you could have done differently, problems you encountered, how your results compare to other peoples' results, etc.
% Go through each problem individually, and then in the end add general remarks and discussion points which are outside the problems themselves but that you think may be valuable to share with the reader.
% This section can have several subsections.


% Overall Discussion of how the problem is solved
The problem of improving debugging for optimized \emph{Rust} code is a very complex problem and a very large one(the problem is fully explained in section \ref{sec:problemdefinition}).
To make it easier to solve this problem, the problem was divided into two parts and had a lot delimitations.
The first part of generating more debug information was not very successful, because all of the options found to generate more debug information are well known.
Thus none of them are really an improvement because most \emph{Rust} developers already use them.
But the other part of creating a debugger that improve on optimized \emph{Rust} code on embedded systems was successful.
The main reason for this is that the two supported debugger by the \emph{Rust} team had problems with evaluating the correct value for the enum type.
There is also the fact that the solution of this theis has contibuted with at debugging library that simplifies the process of retriving debug information form the \gls{DWARF} format.


\subsection{Debug Information Generation}
% My Results Compared to expected results
This thesis was not really able to improve the amount of debug information generated by \gls{rustc} and \gls{LLVM}.
There are some options mention in the section \ref{sec:settingscomparison} that generate debug information, but they are well known and a must to debug \emph{Rust} code.
Thus the result presented there is noting new for most developers that program in \emph{Rust}.
To really improve on the amount of debug information generated one has to work on the compiler or \gls{LLVM} and make the optimization passes keep more information.


\subsection{Debug Experience For Optimized Rust Code}
% My Results Compared to expected results
At the beginning of this thesis it was thought that the \gls{GDB} debugger was not able to evaluate variables where the value is located in registers.
This thought came from the observation that \gls{GDB} for the most time prints that almost all variables are optimized out when debugging optimized code.
Thus it was thought that those variables were completely removed from the optimized code.
But as it turns out they weren't, instead they were just optimized out at that pedicular point.
Keeping these expectation in mind the result in section \ref{sec:debuggercomparison} were a bit disappointing.
The only improvement that could be made for this problem is that different messages are displayed for the different situations.
This helps the user understand more what is happening in the code because they can now know if a variable is completely optimized out of the code or if it is just temporally optimized out.


Unexpectedly there was another problem with both debugger \gls{GDB} and \gls{LLDB} that could be improved on.
That problem is that both mentioned debuggers had problems with the evaluation of the \emph{enum} type in \emph{Rust}(see section \ref{sec:debuggercomparison} for the specific problems they have).
The reason for this problem is that many other programming language doesn't allow \emph{enums} to have any value stored in them like \emph{Rust} allows.
The \gls{LLDB} debugger had much more problems with this then \gls{GDB} which only gave the wrong value when the enum variant was optimized out.
Thus unexpectedly the debugger in this thesis could improve on that by evaluating the correct value.
And in the case of the value of the  enum variant being optimized out it could display that it was optimized out, thus not giving the wrong value as \gls{GDB} does.


\subsubsection{Debugging Rust Code On Embedded Systems}
% My Results Compared to expected results
The experience of debugging \emph{Rust} code on embedded systems with both \gls{LLDB} and \gls{GDB} is not very good.
There is a lot of configuring that has to be done and both require a program like \emph{openocd} that handles the communication between the debugger and the target device.
Removing this need of using a program like \emph{openocd} made the debugging experience a lot better using the debugger presented in this thesis.
The reason being that it takes fewer steps to start debugging.


\subsubsection{Contributing to the Rust Debug Community}
% My Results Compared to expected results
As mention before this problem is huge and complex thus to really make a change in debugging optimized \emph{Rust} code more people have to contribute.
One of the best ways of getting more people involved is by making it easier to contribute.
The debugging library \emph{rust-debug} does just that by simplifying the process of retrieving debug information from dwarf.
If more developers start using \emph{rust-debug} will force the library to also become better and intern also force \emph{gimli-rs}, \gls{rustc}, \gls{LLVM} and \gls{DWARF} to become better.

