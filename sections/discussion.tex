% Discuss how you solved your problems from 1.3, and what the results were (from section 5).
% Describe alternative solutions, what you could have done differently, problems you encountered, how your results compare to other peoples results, etc.
% Go through each problem individually, and then in the end add general remarks and discussion points which are outside the problems themselves but that you think may be valuable to share with the reader.
% This section can have several subsections.


% Overall Discussion of how the problem is solved


\section{Debug Information Generation}
% My Results Compared to expected results
This thesis was not really able to improve the amount of debug information generated by \emph{rustc} and \emph{LLVM}.
There are some options mentioned in the section \ref{sec:settingscomparison} that generate debug information, but they are well known.
Thus the result presented there is nothing new for most developers that program in \emph{Rust}.
To really improve on the amount of debug information generated, one has to work on the compiler \emph{rustc} or \emph{LLVM}.


\section{Debug Experience For Optimized Rust Code}
% My Results Compared to expected results
At the beginning of this thesis it was thought that \emph{GDB} was not able to evaluate variables with values stored in registers.
This thought came from the observation that \emph{GDB} for the most part prints that the variables are optimized out, when debugging optimized code.
Thus it was thought that those variables were completely removed from the optimized code.
But as it turns out they were not, instead they were just optimized out at that particular point.


Keeping these expectation in mind the result in section \ref{sec:debuggercomparison} were a bit disappointing.
The only improvement that could be made for this problem is that different messages are displayed for the different cases.
This makes it much clearer to the user how the variable is optimized out.


Unexpectedly there was another problem with the debuggers \emph{GDB} and \emph{LLDB} that could be improved on.
That problem is that both mentioned debuggers had problems with the evaluation of the \emph{Rust} \emph{enum} type.
The reason for this problem is that many other programming language does not allow \emph{enums} to have any value stored in them like \emph{Rust} allows.


The \emph{LLDB} debugger had much more problems with this then \emph{GDB} which only gave the wrong value when the enum variant was optimized out.
Thus unexpectedly the debugger in this thesis could improve on that by evaluating the correct value and by showing a correct optimization out messages, which \emph{GDB} did not do.
There is a \emph{VSCode} extension that fixes the problem of \emph{GDB} displaying the wrong variant of enum when the variant is optimized out.
It is called \emph{cortex-debug} and its git repository can be found here \cite{cortex-debug}.
%and in the case of the value of the  enum variant being optimized out it could display that it was optimized out, thus not giving the wrong value as \emph{GDB} does.


\subsection{Debugging Rust Code on Embedded Systems}
% My Results Compared to expected results
The experience of debugging \emph{Rust} code on embedded systems with both \emph{LLDB} and \emph{GDB} is not very good.
There is a lot of configurations that has to be done and both require a program like \emph{openocd} that handles the communication between the debugger and the target device.
Using \gls{erd} made the debugging experience a lot better because it does not need to use a program like \emph{openocd}.
The reason for it being better it that it takes fewer steps to start debugging.


\section{Accuracy of the \gls{DWARF} Location Ranges}\label{section:loc-ranges}
% The accuracy of the Location list entry ranges.
While working on \emph{rust-debug} and \gls{erd} it was discovered that values can sometimes live longer on the debugged target then described in \gls{DWARF}.
This means that some of the values can potentially be read when \gls{DWARF} says that they have no location.


The documentation for \emph{LLVM} \cite{llvm-dbs} mentions three major factors that effect the variable location fidelity, they are:

\begin{enumerate}
  \item Instruction Selection
  \item Register allocation
  \item Block layout
\end{enumerate}

The documentation about the three major factors does not mention a lot about how the ranges could be set to tight.
Thus to be able to find if this can be improved on, one has to have a good understanding of \emph{LLVM}, which is out of scope for this thesis.


The documentation also mention that some location changes are ignored by \emph{LLVM} in some situations.
One situation they mention is that location changes is ignored for the prologue and epilogue code of a function.
But this should not be a problem because most debuggers will step over the prologue and epilogue code.



\section{Contributing to the Rust Debug Community}
% My Results Compared to expected results
This problem is huge and complex so to really make a change more people have to contribute.
One of the best ways of getting more people involved is by making it easier to contribute.
The debugging library \emph{rust-debug} does just that by simplifying the process of retrieving debug information from \gls{DWARF}.
%If more developers start using \emph{rust-debug} will force the library to also become better and intern also force \emph{gimli-rs}, \emph{rustc}, \emph{LLVM} and \gls{DWARF} to become better.


