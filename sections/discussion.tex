% Discuss how you solved your problems from 1.3, and what the results were (from section 5).
% Describe alternative solutions, what you could have done differently, problems you encountered, how your results compare to other peoples results, etc.
% Go through each problem individually, and then in the end add general remarks and discussion points which are outside the problems themselves but that you think may be valuable to share with the reader.
% This section can have several subsections.


% Overall Discussion of how the problem is solved

\section{Usefulness of \emph{rust-debug}} % TODO: Change name of section
Using the \emph{rust-debug} library makes it a lot easier to get debug information form \gls{DWARF}.
One reason, is that it takes a lot less knowledge about \gls{DWARF} to retrieve debug information.
The documentation for \emph{rust-debug} is a lot less text than the specification for the \gls{DWARF} format.
Thus, it takes less time to read and understand, which makes it easier use and get debug information.


Also, the amount of code needed to get the debug information is a lot less using \emph{rust-debug}, as the result of section \ref{sec:evalrd} shows.
Using the amount of code lines to measure complexity is not the most accurate method.


\section{Debug Experience For Optimized Rust Code} %TODO: Rewrite section
% My Results Compared to expected results
At the beginning of this thesis, it was thought that \emph{GDB} was not able to evaluate variables located in registers.
This thought came from the observation that \emph{GDB} for the most part prints that the variables are optimized out, when debugging optimized code.
Thus, it was thought that those variables were not completely removed from the optimized code.
However, it turns out that \emph{GDB} was right in that they were completely optimized out.


Keeping these expectations in mind, the result in section \ref{sec:debuggercomparison} is disappointing.
Because the goal was to create a debugger that could improve on this problem.


Unexpectedly, both \emph{GDB} \emph{LLDB} has other smaller problems.
Such as \emph{GDB} parsed $64$-bit integers as $32$-bit.
Those small problems might be specific to the debuggers \gls{cli}, and thus not present in other releases of the debuggers.
However, the problems show that \emph{erdb} has some small advantages.


\subsection{Debugging Rust Code on Embedded Systems}
% My Results Compared to expected results
The experience of debugging \emph{Rust} code on embedded systems with both \emph{LLDB} and \emph{GDB} is not very good.
There are a lot of configuring, and both require a program like \emph{openocd} that handles the communication between the debugger and the target device.
Using \gls{erdb} is easier, because it removes the step of starting a separate program.


\section{Accuracy of the DWARF Location Ranges}\label{section:loc-ranges}
% The accuracy of the Location list entry ranges.
While working on \emph{rust-debug} and \gls{erdb} it was discovered that variables can sometimes live longer on the debugged target then described in \gls{DWARF}.
This means that some variables can potentially be read when \gls{DWARF} says that they have no location.


The documentation for \emph{LLVM} \cite{llvm-dbs} mentions three major factors that effect the variable location fidelity, they are:

\begin{enumerate}
  \item Instruction Selection
  \item Register allocation
  \item Block layout
\end{enumerate}

The documentation about the three major factors does not mention a lot about how the ranges could be set too tight.
Thus, to be able to find if this can be improved on, there has to be a good understanding of \emph{LLVM}, which is out of scope for this thesis.


The documentation also mention that some location changes are ignored by \emph{LLVM} in some situations.
One situation they mention, is that location changes is ignored for the prologue and epilogue code of a function.
However, this should not be a problem, because most debuggers will step over the prologue and epilogue code.

