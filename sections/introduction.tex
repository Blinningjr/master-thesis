% Give the reader an overview of the rea.
% Try to focus on the scientific area, but do not forget the red thread that binds the rest of the introduction together.

A key part of programming has always been debugging the computer program.
Debugging is the process of finding and resolving errors, flaws or faults in computer programs.
These errors, flaws or faults are also commonly referred to as a bug or bugs in the field of computer science.
Debugging has become more difficult to do over the years because of the increasing complexity of computer programs and the hardware.
Thus, the importance of better debugging tools have become essential to make the process of debugging easier and more time efficient.
This is especially true for debugging  embedded systems because of the close relation to hardware.


One of the first types of debugging tools made, and one of the most useful is called a debugger.
A debugger is a program that allows the developer to control the debugged program in some ways, for example stopping, starting and resetting.
It is also able to inspect the debugged program by for example displaying the values of the variables.
Debuggers are especially useful when programming embedded systems, because a debugger enables the developer to inspect what is happening in the \gls{mcu}.
Thus giving the developer a complete view of what the program is doing.
However, they are also a very useful tool for testing.


Debugging today works by having the compilers generate debug information when compiling the program.
The debug information is stored in a file, the information is stored in a special format designed to be read by a debugger or other debugging tools.
One of the most popular of these formats is called \gls{DWARF}, it is a complex format that is explained in section \ref{sec:dwarf}.


The debug information stored in the \gls{DWARF} file can be used to find the location of the variables values.
Which in most cases are stored on the call stack in memory, section \ref{sec:callstack} explains what a call stack is.
The debug information also contain the data type information of the variable, it is used to interpret the raw value of variable found in memory into a typed value.


The main problem with debugging optimized code is that values of variables are sometimes stored in registers.
Registers are faster to access then other memory and has a much lower capacity.
Thus, storing values there often increases the speed of the programs, but the values are not persistent, because they get overwritten.
This makes debugging a lot harder because the values are very short lived compared to values that are stored on the call stack.
Which often have the same life span as the stack frame.
I refer the reader to section \ref{sec:regmem} for more detailed information about registers and memory.
%Then there is the problem of debuggers not being able to utilize all the available debug information.


\section{Background}
% What has been done already, and why does this work need to be solved.
% Typically if the masters project is issued by a company it is because the company already has one part, but wish to improve it or extend it somehow.
% Describe the background to your work.
In the \emph{Rust} programming language community there was no project focusing on creating a debugger for embedded systems when this thesis was started.
There was even less focus on improving the debugging of optimized \emph{Rust} code.
One of the larger project focusing on debugging is called \emph{gimli-rs}, one of the main goals of the project is to make a \emph{Rust} library for reading the debugging format \gls{DWARF}.
Then there are other projects like \emph{probe-rs} that focus on making a library that provides different tools for interact with a range of \glspl{mcu} and debugging probes.
One of their newest tools that has not been released yet is a debugger that also uses the \emph{gimli-rs} library to read the \gls{DWARF} file.

When it comes to improving generation of debug information there is some work being done on the \emph{LLVM} project, but there is no focus on improving debugging for optimized code in the \emph{LLVM} project.


\section{Motivation}
% Why is your work important? Typically this section relates strongly to the problems that you define in 1.3.
% The motivations can be societal, economical, or other things, but try and look past the task at hand and find out what impact your results will have.

% Motivations bullet points
%	* Optimized rust code is up to 100 faster.
% 	* Improving the state of debugging.
% 	* Contributing with a solution written in Rust.
% 	* Contributing a debug rust library / simplifying debugging.
% 	* Shinning a light on the obstacles.
%	* Companies spend lot of money on testing but not on verifying if there program is correct, which debugging is a important tool for verifying.


% Optimized rust code is up to 100 faster.
A motivation for this thesis is that optimized \emph{Rust} code can be $10-100$ times faster than unoptimized code according to the \emph{Rust} performance book \cite{perf-book}.
That is a very large difference in speed compared to other languages like \emph{C} for example, were the optimized code can be about 1-3 times faster than the unoptimized code as can be seen in the paper \cite{clang-opt}.
Thus for a language like \emph{C}, it is much more acceptable to not be able to debug optimized code because the difference is not that large compared to \emph{Rust} code.
But in the case of \emph{Rust}, the difference is so large that some programs are too slow to run on \glspl{mcu} without optimization.
This is a problem because debuggers are bad at debugging optimized code as explained in the introduction, and unoptimized code is to slow to run.
That is why there is a need for better debuggers that can provide a good experience when debugging optimized \emph{Rust} code.


% Debugging is not as important for rust, but is still needed for embedded systems
An argument against the need of debugging embedded systems is that the \emph{Rust} compiler will catch most of the errors.
This is especially true regarding pointers and memory access, which are two common causes of bugs in programming languages like \emph{C} and \emph{C++}.
Because most \emph{C} and \emph{C++} compilers have very few restrictions on how pointers can be used, and the value pointed to thus can be removed while the pointer still exists. 
Thus, there is less need for a debugger that can debug \emph{Rust} code than there are debuggers that can debug \emph{C} and \emph{C++} code.
However, when it comes to embedded applications there is still a need for debugging with such a debugger.
One reason is because \emph{Memory-mapped I/O} is used to preform input/output (\emph{I/O}) between the \emph{CPU} and peripheral devices.
And a debugger is very good tool for showing the state of these peripheral, which makes the development and testing much easier.
Another reason is that hardware bugs are much easier to find if it is possible to inspect the state of a device easily.


% Improving the state of debugging. % TODO: Rewrite this paragraph
Another motivation for creating a debugger for embedded systems is that the two supported debuggers for \emph{Rust} by the \emph{Rust} team are \emph{LLVM} and \emph{GDB}, which at the time of writhing this both requires another program to interact with the \gls{mcu}.
An example of such a program that is commonly used is \emph{openocd} (openocd homepage \cite{openocd}), which needs to be setup as a \emph{GDB} server that the debugger connects to.
This complicates the process of debugging and makes for a needlessly complex experience, especially for new developers.


% Contributing with a solution written in Rust.
Many of the debuggers used for debugging \emph{Rust} code are written in other programming languages, and there is not a lot of debugging tools written in \emph{Rust} yet.
Thus, one of the key motivations is to write a debugger in \emph{Rust}, which will also lead to the debugger having all the benefit of memory safety that \emph{Rust} provides.


%% Contributing a debug rust library / simplifying debugging.
Currently there knowledge needed to write debugging tools that utalisizes the information stored in the \gls{DWARF} format is very high.
Thus, another motivation is to make a abstraction layer that reduced the amount of knowledge needed to some degree.
This will be achieved by creating a debugging library, which hopefully will help other get information from the \gls{DWARF} format and help them understand it better.


\section{Problem definition}
%\subimport{introduction/}{problem-definition.tex}
% This is really the section you should start writing first, even if it's located as 1.3.
% What scientific problems are you solving in your thesis.
% The reason why you should start defining these is that they define what you should write in all the other sections.
% The introduction gives an overview of the area of your problems.
% The background offers the background to why you are working with your problems.
% The motivation gives a motivation to why you are solving the problems.
% The related work described work which relates to your problems.
% The implementation describes how you have implemented a solution to your problems.
% The evaluation evaluates whether you have actually solved your problems.
% The discussion discusses each individual problem, how you addressed it, alternative solutions and shortcomings, etc.
% The conclusions and future work describes the final outcome of how you solved your problems and what is left to do. 
 
% If you write your problems first it is so much easier to write all the other sections because you already know what the focus of each section should be. It prevents a lot of the writers block that people often suffer from.

The main problem of this thesis is to improve the experience of debugging optimized \emph{Rust} code on embedded systems.
The scope of that problem is to big for one master thesis, thus the focus will be on laying the groundwork for solving the problem.
There are two goals that needs to be achieved for this to be consider done.


Implement a debugger with the minimum needed functionality for debugging optimized \emph{Rust} code on a embedded system, is the fist goal.
This debugger is required to be designed so that it is easy to use and can easily be improved upon.
The list in section \ref{sec:delimitations} lists the minimum needed features that this debugger needs to have.


The second goal is to research future possible solutions for improving debugging of optimized \emph{Rust} code, and discussing there pros and cons.
For this goal to be consider achieved, this thesis should at least bring up three possible solutions.
These solutions should not only discussing what can be done on the debugging side of the problem, but how the compiler can be improved.


%\section{Equality and ethics}
% Equality and ethics are learning objectives for the program and should be reflected upon in the thesis if applicable.
% This section can be omitted if not at all relevant to the problem definition, but in many cases the thesis topic touches upon these topics even if it is outside the scope of the work itself and in such cases a single paragraph may be sufficient to cover the reflection.



%\section{Sustainability}
%TODO

% Similar to the equality and ethics section this is one of the learning objectives for the program and should be reflected upon in the thesis if applicable.
% For a quick overview of what is considered to be included in sustainability you can see the united nations list of sustainability goals:
% https://www.un.org/sustainabledevelopment/sustainable-development-goals/ 



\section{Delimitations}
\label{sec:delimitations}
% Describe what is not covered in the thesis.
% Things you realize may have to be addressed to create a complete solution, but that would be too much work, or that may simply be out of the scope of your scientific area.


% Delimitations
% 	* Making changes to the compiler(llvm).
%	* Focusing on the bare minimum of debugger features.
%	* Making changes to DWARF standard.
%	* Limiting supported chips and platforms.
%	* Limiting to only support DWARF debug info and not the CodeView format. Source: https://llvm.org/docs/SourceLevelDebugging.html
%	* Limiting the depth of detail how dwarf works.
%	* Limiting it to a CLI and DAP server plus extension.


%% Focusing on the bare minimum of debugger features
Currently there are a lot of different debugging features that other debugger have.
Many of them are advanced and complicated to implement.
Thus, it is decided to limit the amount of features to the ones that are most important, to keep the scope of this thesis reasonable.
The following is the list of features the debugger is required to have:

\begin{itemize} \label{list:debuggerfeatures}
  \item Controlling the debugging target by:
  \begin{itemize}
    \item Starting/Continuing execution.
    \item Stopping/Halting execution.
    \item Reset execution.
    \item Stepping one machine code instruction.
  \end{itemize}
  \item Set and remove breakpoints.
  \item Virtually unwind the call stack.
  \item Evaluating variables and there types.
  \item Finding source code location of functions and variables.
  \item A \acrfull{cli}.
  \item Support the \emph{Microsoft} \acrfull{dap}.
\end{itemize}


% Limited to only supporting one chip and platform.
Debugging embedded systems requires the debugger knows certain information about the target system, like the architecture.
Supporting every \gls{mcu} out there would be to big of a scope for this thesis.
Thus, the debugger is only required to work with the target system that is available.
Which is a \emph{Nucleo-64, STM32F401RET6 64 pin}.

%% Limiting supported chips and platforms.
%When debugging code on embedded systems the debugger needs to know a lot about the hardware, and some of these hardware properties differ depending on the hardware.
%The following are some of the hardware properties that needs to be known:
%
%\begin{itemize}
%  \item Number of registers.
%  \item Which of the registers that are considered special.
%  \item The endianness of the memory.
%  \item The machine code instruction set the \gls{mcu} is using/supports.
%\end{itemize}

%% Making changes to the compiler(rustc and llvm).
%One of the main problems for getting a debugger to work for optimized code is getting the compiler to generate all the debug information needed.
%In the case of the \emph{Rust} compiler \emph{"rustc"}  it is the \emph{LLVM} library that mostly handles the debug information generation.
%\emph{LLVM} is a very large project that many people are working on, and thus improving on \emph{LLVM} is out of scope for this thesis.
%The same goes for improving \emph{"rustc"}.
%%Thus this thesis is limited in solving this problem by using existing configurations for \emph{rustc} and \gls{LLVM}.


% Limiting to only support DWARF debug info and not the CodeView format. Source: https://llvm.org/docs/SourceLevelDebugging.html % TODO
The compiler backend \emph{LLVM} that \emph{rustc} uses supports two debugging file formats.
One of them is the format \gls{DWARF}, the other one is \emph{CodeView} which is developed by \emph{Microsoft}.
To make a debugger that supports both formats would be a lot of extra work that does not contribute to solving the main problem of this thesis.
Thus it has been decided to only support the \gls{DWARF} format, because it has good documentation.


% Making changes to DWARF standard.
The scope of this thesis does also not include changing or adding to the \gls{DWARF} format.
The main reason is that it takes years for a new version of the standard to be released, and thus there is not enough time for this thesis to see, and realize that change or addition.
Another reason is that even if a new version of the \gls{DWARF} format could be released in the span of this thesis, it would take a lot of time before the \emph{Rust} compiler would be updated to use the new standard.
%Currently the newest \gls{DWARF} version is 5 but the \emph{Rust} compiler still uses the \gls{DWARF} 4 format.


% Will not explain every detail in dwarf.
The \gls{DWARF} format is very complex but provides good documentation.
Thus the explanation of \gls{DWARF} in section \ref{sec:dwarf} will not go into every detail of \gls{DWARF}.
Instead it will focus on explaining the minimum theory to understand the implementation of the debugger.
For further details we refer the reader to \cite{dwarf}.


%Many of the debuggers today have a lot of functionality to help the user understand what is happening in the program that they are debugging.
%An example of these functionality are debuggers that support the ability to go backwards in the program.
%Functionalities like this are useful but dose not contributing much to the main problem of this thesis which is debugging optimized code.
%%Which is that most of the source code variables get optimized away and thus making it extremely hard to understand what is happening in the code.
%So to keep this thesis focused on the main problem the feature the debugger will have is restricted to virtually unwinding the stack, evaluating stack frames and there variables and lastly the ability to add and remove breakpoints.
%The debugger will also have the ability to control the program by stopping, continuing and stepping an instruction which are important debugger functionalities that does not require debug information.


%To support all the different \glspl{mcu} would be too much work for this thesis.
%Thus the debugger is limited to work with the \emph{Nucleo-64 STM32F401} card because it is the one that was available at hand, and it will only support the \emph{arm Thumb mode} instruction set.
%The debugger will be design to work with other similar \gls{mcu} but to test and grantee that it will work with them is to much work for this thesis.


%% Limiting it to a CLI and DAP server plus a VSCode extension.
%Another part of this thesis is the interaction between the user and the debugger.
%Existing debugger like \emph{GDB} both have a \emph{CLI} and a \acrfull{gui}, thus it is up to the user which one they want to use.
%From a usability perspective the debugger in this thesis should also have both of the option for the user to choose from.
%A \emph{CLI} is not that much work to implement but a \acrshort{gui} takes a lot of work to implement.
%Luckily \emph{Microsoft} has made a protocol for debuggers that specifies an adapter that handles the communication between the \acrshort{gui} and the debugger.
%This protocol is called \acrfull{dap}\cite{dap} and is used by \emph{VSCode}.
%Thus the scope of the debugger will include implementing the \acrshort{dap} protocol and a simple extension for \emph{VSCode}.


%% Limiting the depth of detail how dwarf works.
%The \gls{DWARF} format is very extensive and supports a lot of different program languages, the specifications for the different languages are a little different from each other.
%Because this thesis is about \emph{Rust} code the thesis will only go into detail in how to read the \gls{DWARF} format for \emph{Rust}.
%The specification for the \gls{DWARF} format is also very good at explaining how the information is structured.
%Thus a this thesis will not go into all the detail in how to read the \gls{DWARF} format instead it will focus on explaining how the information in the \gls{DWARF} format can be used in combination to get important information that the user wants.

% TODO: Add sources where needed in this section



%\section{Thesis structure}
% Describe how the rest of your thesis is organized.
% (e.g. In section 2 we discuss, in section 3 there is a... etc.).
% This is really just to help guide the reader to where different parts of your work can be found.

%TODO
