% Primarily this section should be about scientific methods and theories you need to evaluate/compare/invent to solve your problems from 1.3.
% In some cases it may be ok to describe different technologies, but the purpose is to describe something and then draw a conclusion from that.
% Example, if you decide to discuss different databases, it may be for the purpose of selecting the best type for your implementation later on (based on for example data representation, scalability, speed, etc.).
% Optimally the problems in 1.3 are not solved by anyone else yet, in which case this section needs to describe how to solve them (new algorithms, mathematical approaches, etc.).
 
% This section can have a lot of subsections (3.1, 3.2, 3.3, etc).

% TODO: Explain Unwinding call stack

To virtually unwind the \emph{call stack} entail the task of restoring the code location and the register values for each \emph{subroutine activation}, it also entail the task of find the location of the corresponding \emph{call frame} on the stack.
Each \emph{subroutine activation} has a code location within the subroutine that show where it stopped for any reason, the reason could be that a breakpoint was hit, it was interrupted by a event or it could be location were it made a call.
As mention the \emph{subroutine activation} also has some register values at the mention code location that may or may not need to restored depending on if the activation is the last one or not.
Lastly a \emph{subroutine activation} has a corresponding \emph{call frame} on the stack that is identified by the \gls{cfa}.
The \gls{cfa} is the value of the stack pointer in the previous stack frame when it is at the call location of the current \emph{stack frame}, one thing to note is that the \gls{cfa} is not the same value as the stack pointer when entering the current \emph{call frame}(see \cite{DWARF} page 126).

Accessing one of the \emph{subroutine activation} requires that the activation stack is virtually unwind to get to the desired activation, there is only one exception to this and that is if the top activation is desired.
That is because all of \emph{activation} information location is known thus it is easy to read that information form the registers and memory. 
It is called \emph{virtually unwinding} because none of the value in the registers or memory are changes which means that the state of the target is not changed.
In general the steps to virtually unwinding the \emph{activation} is to begin with calculating the \gls{cfa} of the previous \emph{activation}, the code location of the previous \emph{activation} and to virtually restore any registers if needed.
Then the same thing can be done to the previous \emph{activation} and so it repeats until the desired \emph{activation} is reached.
This process is required to start with the top \emph{activation} because it is the only one that is known and the process has 
to be stopped if the bottom \emph{activation} is reached.

Any subroutine can have some prologue code that is in the beginning of the subroutine  and epilogue code that is at the end.
The prologue code is used to preserve the values of registers over the duration of the subroutine, this is done by allocating some extra space on the call stack for the \emph{call frame} which is used to store the register values.
Then the epilogue code is used to restore these values to the registers before returning to the previous frame.
Using this fact the compiler generates debug information that enables a user to virtually restore these preserved registers and that is what is done when virtually unwinding the \emph{activations}.
One thing to note is that the prologue and epilogue code are not always continues blocks of code that are in the beginning and end of a subroutine.
Instead sometimes the store and read operation are moved into the subroutine.
There more of these special cases that the compiler does and some that are hardware specific, to read more about them see \cite{DWARF} page 126-127.

The location information for finding \gls{cfa} and the registers for a \emph{activation} is stored in a table, that consist of virtual unwinding rules and addresses.
In the first column of the table the code addresses are located, they are used to identify that all the virtual unwinding rules on that row applies for that code address.
Every machine code line is meant to have these rules but because many of the rows are exactly the same many of those rows are removed from the table to save storage space.
The second column is also special because it contains the virtual unwinding rules for \gls{cfa}, these rules are eiter a \gls{DWARF} expression that needs to be evaluated in the same way that the variables are in section \ref{sec:evaluate-variable} or a register values plus some singed offset.
All the other columns contain virtual unwinding rules for all the register and they are in orders from $0$ to $n$, see figure \ref{fig:stacktracetable} for a visual example of the table.


\begin{figure}[h]
    \centering
    \includegraphics[width=1.0\textwidth]{stacktrace-table.png}
    \label{fig:stacktracetable}
\end{figure}


There are a number of different virtual unwinding rules for the registers that are called register rules in the \gls{DWARF} specification \cite{DWARF}, these are listed on page 128.


