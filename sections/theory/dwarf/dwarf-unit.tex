% Primarily this section should be about scientific methods and theories you need to evaluate/compare/invent to solve your problems from 1.3.
% In some cases it may be ok to describe different technologies, but the purpose is to describe something and then draw a conclusion from that.
% Example, if you decide to discuss different databases, it may be for the purpose of selecting the best type for your implementation later on (based on for example data representation, scalability, speed, etc.).
% Optimally the problems in 1.3 are not solved by anyone else yet, in which case this section needs to describe how to solve them (new algorithms, mathematical approaches, etc.).
 
% This section can have a lot of subsections (3.1, 3.2, 3.3, etc).


% TODO: Explain DWARF Compilation Unit
The compiler when compiling a source program will most often generate one compilation unit for each project/library.
There are some cases when multiple partial compilation units will be generated instead.
The compilation units are store in the \gls{DWARF} section \emph{.debug\_info}.
These compilation units are structured the same as the sources code, which makes it easy to relate between the debug target state and the source code.


%Finding the correct compilation unit can easily be done looking it up in the \gls{DWARF} section \emph{.debug\_aranges} using the current machine code address.
The first \gls{die} in the \gls{tree} of the compilation unit will have the tag \emph{DW\_TAG\_compile\_unit}.
This \gls{die} has a lot of useful debug information about the source file, one being the compiler used and the version of it.
It also says which programming language the source file is written in and also the directory and path of the source file.


A \gls{die} in the \gls{tree} can have multiple children, the relationship between the \gls{die} and the children is that all the children belong to the \gls{die}.
An example of this is if there is a function \gls{die}, then the children of the function \gls{die} will be \glspl{die} that represent parameters and variables that are declared in that function.
Thus if the source code has a function declared in a function then one of the children to the first functions \gls{die} will be the second functions \gls{die}.
This makes it is easy for the debugger to know everything about a function by going through all of its children.

