% Primarily this section should be about scientific methods and theories you need to evaluate/compare/invent to solve your problems from 1.3.
% In some cases it may be ok to describe different technologies, but the purpose is to describe something and then draw a conclusion from that.
% Example, if you decide to discuss different databases, it may be for the purpose of selecting the best type for your implementation later on (based on for example data representation, scalability, speed, etc.).
% Optimally the problems in 1.3 are not solved by anyone else yet, in which case this section needs to describe how to solve them (new algorithms, mathematical approaches, etc.).
 
% This section can have a lot of subsections (3.1, 3.2, 3.3, etc).


Values in registers that need to be preserved during the execution of a subroutine will be push onto the call stack.
This is done by the prologue code that is executed at the start of the subroutine.
Then when the subroutine is finished executing, the stored register values are popped off the stack.
This is done by the epilogue code that is at the end of the subroutine.
The prologue and epilogue code is generated by the compiler.


One thing to note is that the prologue and epilogue code are not always continuous blocks of code that are in the beginning and end of a subroutine.
Instead sometimes the store and read operation are moved into the subroutine.
There are more of these special cases that the compiler does, and some that are hardware specific, to read more about them see \cite{dwarf} page 126-127.

