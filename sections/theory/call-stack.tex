% Primarily this section should be about scientific methods and theories you need to evaluate/compare/invent to solve your problems from 1.3.
% In some cases it may be ok to describe different technologies, but the purpose is to describe something and then draw a conclusion from that.
% Example, if you decide to discuss different databases, it may be for the purpose of selecting the best type for your implementation later on (based on for example data representation, scalability, speed, etc.).
% Optimally the problems in 1.3 are not solved by anyone else yet, in which case this section needs to describe how to solve them (new algorithms, mathematical approaches, etc.).
 
% This section can have a lot of subsections (3.1, 3.2, 3.3, etc).

The values of a program needs to be temporary stored some were on the computer were it can easily be access while running the program.
The two ways the computer can do this is to either store it in a register or in the memory.
Registers are very limited in space and are very volatile thus it is good for storing values that are needed often in a short amount of time.
Memory is slower but has a lot more space and is thus much more useful for storing values that will be needed in a while.
The compiler will compile the program to store the different variables and values in the registers and memory in a structured way so it is easily managed.

There is no real structure for the registers except that certain registers have a specific purpose, which can be the \gls{pc} for example.
A \gls{pc} is a register that keeps track of which machine code instruction the program is currently at.
There are other important registers like the stack pointer register and more.
On the other hand the memory all structure and one of the structures is a stack that consist of stack frames/call frames, the stack is called \emph{call stack}.


\subsubsection{Call Stack}
% \subimport{theory/}{.tex}
The Call stack is a stack in the memory that holds stack frames which intern contain information about the values of variables and other values.
A stack is a data structure that consist of a number of elements that are stacked on top of each other and the only two operations available for a stack is push and pop.
The push operations adds a new element on top of the stack and the pop operation removes the top element of the stack.
Other key characteristics are that it is only the top element that can be access thus too reach the lower elements all the above elements needs to be popped.
The call stack is used to keep track of all the stack frames which holds almost all the values of the running program, the values are also present in the registers and in the heap which is also located in the memory.
An example of a call stack can be seen in the figure \ref{fig:callstack}.


\begin{figure}[h]
	\centering
	\includegraphics[width=1.0\textwidth]{call-stack.png}
	\caption{An visual example of how a stack and stack frames can look.}
	\label{fig:callstack}
\end{figure}


\subsubsection{Stack Frame/Call Frame}
% \subimport{theory/}{.tex}
A stack frame or call frame is a element of the call stack that contain variable values for a scope of the running program.
The scope is usually a function that has been called that have its own arguments and variables that are needed to be stored in memory for later use.
Stack frames also contain a return address which is pointer to the machine code that the program should jump to after the computation in the current scope is done.
When the computation is done the stack frame will be popped from the call stack and the previous stack frame will become the current stack frame, check out figure \ref{fig:callstack} for an visual example.

