% Describe existing solutions and other peoples scientific work in the same area.
% Note that the related work should focus around things that relate to your problems in 1.3.
% Example: if you are working on a social networking component which is to aggregate real-time data to automatically update your status in the social network, then your related work is not about other social networks but about different aggregation techniques, activity recognition solutions, etc.

% TODO: Find scientific papers for debugging optimized code.


\subsection{Debugging Optimized Code}
%\subimport{related-work/}{doc.tex}
% Describe existing solutions and other peoples scientific work in the same area.
% Note that the related work should focus around things that relate to your problems in 1.3.
% Example: if you are working on a social networking component which is to aggregate real-time data to automatically update your status in the social network, then your related work is not about other social networks but about different aggregation techniques, activity recognition solutions, etc.


Debugging optimized code has been a problem for a long time.
There have been many scientific papers on how to solve this problem.
One of the most common approaches is to make the optimizations transparent to the user.
The paper \cite{edselc.2-52.0-8497669319919920107} takes this approach by providing visual aids to the user.
These visual aids are annotations and highlights on both the source and machine code which helps the user understand how the source and machine code relate to each other.
Some other papers that takes the same  approach are \cite{adl1996source, edselc.2-52.0-002842706219940105}.
The two main problems with this approach is that the debug information size get a lot larger, and the compilation times get longer as well.


Another approach is to dynamically deoptimize the subroutine that is being debugged as described in the paper \cite{edselc.2-52.0-002699386519920107}.
This gives almost the same level of debugging experience for optimized code as unoptimized code.
The main problem with this approach is that it does not debug the actual optimized code.


There are a lot more approaches for debugging optimized code, but all of them have some drawbacks.
Two of the most common are that compilation times get a lot longer, and the debug information gets a lot larger.
These are two drawbacks most compilers do not want.



%TODO \cite{edselc.2-52.0-002842706219940105}  Debugging Optimized Code Without Being Misled.
%TODO \cite{edselc.2-52.0-002699386519920107}  Debugging Optimized Code with Dynamic Deoptimization.
%TODO \cite{edselc.2-52.0-8497669319919920107} A New Approach to Debugging Optimized Code.


\subsection{The \emph{probe-rs} Debugger}
%\subimport{related-work/}{probe-rs.tex}
% Describe existing solutions and other peoples scientific work in the same area.
% Note that the related work should focus around things that relate to your problems in 1.3.
% Example: if you are working on a social networking component which is to aggregate real-time data to automatically update your status in the social network, then your related work is not about other social networks but about different aggregation techniques, activity recognition solutions, etc.

The \emph{probe-rs} project is currently creating a debugger in \emph{Rust}, which is almost finished.
Their debugger is made for debugging embedded systems.
It uses their other tools in their library to access and control the debug target.
They also use the \emph{gimli-rs} library for reading the \gls{DWARF} format.


The main difference between \emph{probe-rs} and the debugging library \emph{rust-debug} presented in section \ref{subsection:rust-debug} of this thesis, is that \emph{rust-debug} is designed to be platform and architecture independent.
The \emph{probe-rs} library is designed to provide tools for embedded \glspl{mcu} and debug probes only.
While \emph{rust-debug} is designed to provide a layer of abstraction over the \gls{DWARF} debug format, which simplifies the process of retrieving debug information from \emph{DWARF}.

The main pros of \emph{rust-debug} compared to \emph{probe-rs} are:
\begin{itemize}
  \item Platform and architecture independence.
  \item Has a wider range of use cases.
  \item Less dependencies.
\end{itemize}

The main cons of \emph{rust-debug} compared to \emph{probe-rs} are:
\begin{itemize}
  \item More complex to use.
  \item Requires that the user provide the functionality of reading the debug target's memory and registers.
  \item The code is a bit more complex.
\end{itemize}



%\subsection{llvm}
%\subimport{related-work/}{llvm.tex}
%
%\subsection{GDB}
%\subimport{related-work/}{gdb.tex}
%
%\subsection{LLDB}
%\subimport{related-work/}{lldb.tex}
%
%
%\subsection{gimli-rs}
%\subimport{related-work/}{gimli-rs.tex}
%
%\subsection{DWARF}
%\subimport{related-work/}{dwarf.tex}

