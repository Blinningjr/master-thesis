% Describe existing solutions and other peoples scientific work in the same area.
% Note that the related work should focus around things that relate to your problems in 1.3.
% Example: if you are working on a social networking component which is to aggregate real-time data to automatically update your status in the social network, then your related work is not about other social networks but about different aggregation techniques, activity recognition solutions, etc.

\section{Debugging Optimized Code}
% Describe existing solutions and other peoples scientific work in the same area.
% Note that the related work should focus around things that relate to your problems in 1.3.
% Example: if you are working on a social networking component which is to aggregate real-time data to automatically update your status in the social network, then your related work is not about other social networks but about different aggregation techniques, activity recognition solutions, etc.


Debugging optimized code has been a problem for a long time.
Thus, there are many scientific papers on how to solve this problem.
One of the most common approaches is to make the optimizations transparent to the user.
The paper \cite{edselc.2-52.0-8497669319919920107} takes this approach by providing visual aids to the user.
These visual aids are annotations and highlights on both the source and machine code which helps the user understand how the source and machine code relate to each other.
Some other papers that take the same approach are \cite{adl1996source, edselc.2-52.0-002842706219940105}.
The two main problems with this approach is that the debug information size get a lot larger, and the compilation times get longer as well.


Another approach is to dynamically deoptimize the subroutine that is being debugged as described in the paper \cite{edselc.2-52.0-002699386519920107}.
This gives almost the same level of debugging experience for optimized code as unoptimized code.
The main problem with this approach is that it does not debug the actual optimized code, which can cause all sorts of issues.


There are a lot more approaches for debugging optimized code, but all of them have some drawbacks.
Two of the most common drawbacks is that compilation times get a lot longer, and the debug information gets a lot larger.
These are two drawbacks that most compilers try to avoid.



\section{The \emph{probe-rs} Debugger}
%\subimport{related-work/}{probe-rs.tex}
% Describe existing solutions and other peoples scientific work in the same area.
% Note that the related work should focus around things that relate to your problems in 1.3.
% Example: if you are working on a social networking component which is to aggregate real-time data to automatically update your status in the social network, then your related work is not about other social networks but about different aggregation techniques, activity recognition solutions, etc.

The \emph{probe-rs} project is currently creating a debugger in \emph{Rust}, for embedded systems.
It uses their other tools in their library to access and control the debug target.
They also use the \emph{gimli-rs} library for reading the \gls{DWARF} format.


The main difference between \emph{probe-rs} and the debugging library \emph{rust-debug}, presented in section \ref{section:rust-debug} of this thesis, is that \emph{rust-debug} is designed to be platform and architecture independent.
The \emph{probe-rs} library is designed to provide tools for embedded \glspl{mcu} and debug probes only.
While \emph{rust-debug} is designed to provide a layer of abstraction over the \gls{DWARF} debug format, which simplifies the process of retrieving debug information from \gls{DWARF}.
Another difference is that there debugger is not able to evaluate some of the more complex data structures in \gls{DWARF}, but \emph{rust-debug} is able to evaluate them.

The main pros of \emph{rust-debug} compared to \emph{probe-rs} are:
\begin{itemize}
  \item Platform and architecture independence.
  \item Has a wider range of use cases.
  \item Less dependencies.
\end{itemize}

The main cons of \emph{rust-debug} compared to \emph{probe-rs} are:
\begin{itemize}
  \item More complex to use.
  \item Requires that the user provide the functionality of reading the debug target's memory and registers.
  \item The code is a bit more complex.
\end{itemize}





%\section{llvm}
%\subimport{related-work/}{llvm.tex}
%
%\section{GDB}
%\subimport{related-work/}{gdb.tex}
%
%\section{LLDB}
%\subimport{related-work/}{lldb.tex}
%
%
%\section{gimli-rs}
%\subimport{related-work/}{gimli-rs.tex}
%
%\section{DWARF}
%\subimport{related-work/}{dwarf.tex}

